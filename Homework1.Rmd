---
title: "Homework 1"
author: "Sasikanth Nagalla"
date: "5 April 2016"
---
<br/>
<br/>

**Question 1: Random Number Generators**

**1.a**
```{r}
#LGM Method
options(scipen=10)
n <- 10000
a <- 7^5
b <- 0
m <- 2^31 - 1

lgm <- function(n){
rand <- numeric(n)
rand[1] <- 0.001
for (i in 2:n) {
    rand[i] = (rand[i-1]*a)%%m
}
return (rand/m) 
}
unirand <- lgm(n)
mean(unirand)
sd(unirand)
```

**1.b**
```{r}
srand <- runif(n)
mean(srand)
sd(srand)
```

**1.c**

The mean of the LGM random variables is: `r mean(unirand)`.   
The standard deviation of the LGM random variables is: `r sd(unirand)`.
<br/>
The mean of the built-in function random variables is: `r mean(srand)`.
<br/>
The standard deviation of the built-in function random variables is: `r sd(srand)`.
<br/>

The difference in the means is: `r mean(unirand) - mean(srand)`.
<br/>
The difference in the standard deviation is: `r sd(unirand) - sd(srand)`.
<br/>
The findings in (a) and (b) are very close to each other as expected. The more number of random numbers we use the more closer the findings get to each other.
<br/>
<br/>

**Question 2: Probibability Distribution**

**2.a**
```{r}
library(ggplot2)
X <- numeric(n)
p <- c(0.3,0.35,0.2,0.15)
for (j in 1:n){
if (unirand[j] <= p[1]){
    X[j] = -1  
} 
else if (unirand[j] > p[1] && unirand[j] <= sum(p[1:2])){
    X[j] = 0 
}
else if (unirand[j] > sum(p[1:2]) && unirand[j] <= sum(p[1:3])){
    X[j] = 1 
}
else{ 
    X[j] = 2 
}
}
X[1:10]
```


**2.b**
```{r}
qplot(X,geom="histogram", fill = I("blue"), col = I("red"), binwidth = 0.1, main = "Frequency distribution of X")
mean(X)
sd(X)
```

The mean of X is: `r mean(X)`.
<br/>
The standard deviation of X is: `r sd(X)`.
<br/>
<br/>

**Question 3: Binomial Distribution**  

**3.a**
```{r}
m <- 44
p <- 0.64
uniform <- as.numeric(lgm(n*m),n*m)
vec <- which(uniform<p) 
uniform[vec] <- 1
uniform[-vec] <- 0
uniformmatrix <- matrix(uniform,n,m)
binomial <- c(rowSums(uniformmatrix)) 
```

**3.b**
```{r}
qplot(binomial,geom="histogram", fill = I("blue"), binwidth = 0.1, main = "Frequency distribution of X")
prob <- length(which(binomial>=40))/length(binomial)
bprob <- sum(dbinom(40:44,44,0.64))
```

The probability of X is: `r prob`.
<br/>
The probability calculated from the distribution: `r bprob`
<br/>
<br/>

**Question 4: Exponentially distributed**

**4.a**
```{r}
X <- -1.5*log(1-unirand) 
```

**4.b**
```{r}
Fone <- length(which(X>=1))/length(X)
Ffour <- length(which(X>=4))/length(X) 
```

The probability of P(X>=1) is `r Fone`.
<br/>
The probability of P(X>=4) is `r Ffour`.
<br/>
<br/>

**4.c**
```{r}
mean(X)
sd(X)
qplot(X,geom="histogram", fill = I("blue"), binwidth = 0.1, main = "Frequency distribution of X")
```

The mean of X is: `r mean(X)`.
<br/>
The standard deviation of X is: `r sd(X)`.
<br/>
<br/>

**Question 5: Normal Distribution**

**5.a**
```{r}
unirand <- runif(5000)
```

**5.b**
```{r}
#box-muller method
start <- Sys.time()
unimatrix <- matrix(runif(5000),2500,2)
Zone <- sqrt(-2*log(unimatrix[,1]))*cos(2*pi*unimatrix[,2])
Ztwo <- sqrt(-2*log(unimatrix[,1]))*sin(2*pi*unimatrix[,2])
#combine Z1 and Z2 each with 2500 random normal numbers
Z <- rbind(Zone, Ztwo)
end <- Sys.time()
```

**5.c**
```{r}
mean(Z)
sd(Z)
BMtime <- end - start
```

**5.d**
```{r}
start <- Sys.time()
Urand <- matrix(runif(6500),ncol=2)
Vone <- 2*Urand[,1] - 1
Vtwo <- 2*Urand[,2] - 1
w <- Vone^2 + Vtwo^2
Urand <- cbind(Urand,Vone,Vtwo,w)
Urand <- subset(Urand, w<=1)[c(1:2500),]
polarZone <- Urand[,3] * sqrt((-2*log(Urand[,5]))/Urand[,5])
polarZtwo <- Urand[,4] * sqrt((-2*log(Urand[,5]))/Urand[,5])
#combine Z1 and Z2 each with 2500 random normal numbers
polarZ <- rbind(polarZone,polarZtwo)
end <- Sys.time()
```

**5.e**
```{r}
mean(polarZ)
sd(polarZ)
PMtime <- end-start
```

**5.f**
<br/>
The time taken for Box Muller method is: `r BMtime` secs.
<br/>
The time taken for Polar-Marsaglia method is: `r PMtime` secs.
<br/>
The Box-Muller method is more efficient but not always in every case.